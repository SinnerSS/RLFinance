import numpy as np
import pandas as pd
from typing import List, Dict, Union, Optional

from .base_strategy import BaseStrategy

class UniversalPortfolio(BaseStrategy):
    """
    Universal Portfolio strategy enhanced to allow leverage (negative positions).
    
    This implementation maintains a set of candidate constant‐rebalanced portfolios.
    Their weights are generated by “stretching” the simplex via the parameter beta.
    
    On each trading day:
      1. If not the first day, update candidate wealth using yesterday's open-to-close returns.
      2. Compute the aggregated portfolio as the weighted average of the candidates,
         where the weights are the candidate wealths.
      3. Allocate current capital according to the aggregated portfolio weights.
    
    Negative allocations represent short positions.
    """
    def __init__(
        self, 
        data: Dict[str, pd.DataFrame],
        start_date: Union[str, pd.Timestamp],
        end_date: Union[str, pd.Timestamp],
        pool: Optional[List[str]] = None,
        initial_capital: float = 10000.0,
        num_candidates: int = 50,
        beta: float = 1.0,
        seed: Optional[int] = None
    ):
        super().__init__(data, start_date, end_date, pool, initial_capital)
        self.num_candidates = num_candidates
        self.beta = beta
        if seed is not None:
            np.random.seed(seed)
        self.candidate_portfolios = []
        self.candidate_wealth = []
        n_assets = len(self.pool)
        for _ in range(self.num_candidates):
            raw = np.random.uniform(-1, 1, size=n_assets)

            raw_centered = raw - np.mean(raw)
            candidate_weights = (1.0/n_assets) + self.beta * raw_centered

            candidate = {symbol: weight for symbol, weight in zip(self.pool, candidate_weights)}
            self.candidate_portfolios.append(candidate)
            self.candidate_wealth.append(1.0)
        self.last_date = None 
    
    def _update_strategy(self, date: pd.Timestamp):
        """
        For each day (except the first), update each candidate's wealth based on the previous
        day's returns, then compute the aggregated portfolio as the weighted average of candidate portfolios.
        """
        if self.last_date is not None:
            if self.last_date in self.data['open'].index and self.last_date in self.data['adj_close'].index:
                open_prices = self.data['open'].loc[self.last_date]
                adj_prices = self.data['adj_close'].loc[self.last_date]
                returns = {}
                for symbol in self.pool:
                    op = open_prices[symbol]
                    returns[symbol] = (adj_prices[symbol] / op) if op != 0 else 1.0
                for i, candidate in enumerate(self.candidate_portfolios):
                    candidate_return = sum(candidate[symbol] * returns[symbol] for symbol in self.pool)
                    self.candidate_wealth[i] *= candidate_return
        total_wealth = sum(self.candidate_wealth)
        if total_wealth == 0:
            aggregated = {symbol: 1.0/len(self.pool) for symbol in self.pool}
        else:
            aggregated = {}
            for symbol in self.pool:
                aggregated[symbol] = sum(self.candidate_wealth[i] * self.candidate_portfolios[i][symbol]
                                         for i in range(self.num_candidates)) / total_wealth
        self.plan = {symbol: aggregated[symbol] * self.capital for symbol in self.pool}
        self.last_date = date  

    def _update_portfolio(self, date: pd.Timestamp):
        """
        Override the base method to handle negative allocations (short positions).
        
        For each asset:
          - If allocation is positive, buy shares as usual.
          - If allocation is negative, short sell shares (i.e. negative shares)
            and add cash (since selling short raises cash).
        """
        open_prices = self.data['open']
        for symbol in list(self.plan.keys()):
            if symbol in self.pool and date in open_prices.index:
                price = open_prices.loc[date, symbol]
                allocated = self.plan[symbol]
                if pd.notna(price) and allocated != 0:
                    shares = allocated / price
                    if symbol in self.portfolio:
                        prev_shares = self.portfolio[symbol]['shares']
                        prev_entry_price = self.portfolio[symbol]['entry_price']
                        new_total_shares = prev_shares + shares
                        if prev_shares * shares > 0:
                            new_entry_price = (prev_shares * prev_entry_price + shares * price) / new_total_shares
                        else:
                            new_entry_price = price
                        self.portfolio[symbol].update({
                            'shares': new_total_shares,
                            'entry_price': new_entry_price,
                            'entry_date': date
                        })
                    else:
                        self.portfolio[symbol] = {
                            'shares': shares,
                            'entry_price': price,
                            'entry_date': date
                        }
                    self.capital -= allocated
            del self.plan[symbol]
